#!/bin/python

import sys

g_counts = 10

prefix = """/*
 {0}
 This file autogenerated. Do not modify, as all modifications will be overwritten.
*/

#ifndef __JINI_{1}__
#define __JINI_{1}__

namespace jni {2}

"""

class_prefix = """	{2}
	class {1}<{3}>: public MethodBase< {1}<{3}> >
	{0}
	public:
		typedef MethodBase< {1}<{3}> > base_t;
		{1}({4}): base_t({5}) {0}{8}
		bool onInit(JNIEnv* env, jclass clazz, bool _throw)
		{0}
			SigHelper sig(Signatures::buildSig<{7}>());
			if (!sig) return false;
			return base_t::init(env, clazz, sig, _throw{6});
		{8}
"""

class_suffix = """		{1} operator()({2})
		{0}
			return call(Env(), {5}, true);
		{6}
		{1} no_throw({2})
		{0}
			return call(Env(), {5}, false);
		{6}
		bool init_(jclass clazz)
		{0}
			return base_t::ensure(Env(), clazz, false);
		{6}
		bool init_(JNIEnv* env, jclass clazz)
		{0}
			return base_t::ensure(env, clazz, false);
		{6}
	private:
		{1} call(JNIEnv* env, {2}, bool _throw)
		{0}
			if (!base_t::ensure(env, clazz, _throw))
				return {1}();
			{1} _ret = {3}
			if (_throw)
				Exception::check(env);
			return _ret;
		{6}
	{6};

"""

suffix = """
{1} //jni

#endif //__JINI_{0}__
"""

sig_prefix = """
	class SigHelper
	{
		char* sig;
	public:
		SigHelper(char* s): sig(s) {}
		~SigHelper() { free(sig); }
		operator const char*() const { return sig; }
	};

	struct Signatures
	{
		static char* buildSig(const char* ret, const char** args, int len) {
			if (!ret || !*ret) return NULL;
			int buffsize = strlen(ret) + 3;
			for (int i = 0; i < len; ++i) {
				if (!args[i] || !*args[i]) return NULL;
				buffsize += strlen(args[i]);
			}
			char* buffer = (char*)malloc(buffsize);
			if (!buffer) return NULL;
			int ptr = 0;
			buffer[ptr++] = '(';
			for (int i = 0; i < len; ++i)
			{
				strcpy(buffer + ptr, args[i]);
				ptr += strlen(args[i]);
			}
			buffer[ptr++] = ')';
			strcpy(buffer + ptr, ret);
			return buffer;
		}
		template <int len>
		static char* buildSig(const char* ret, const char* (&args)[len]) { return buildSig(ret, args, len); }
"""
null_buildSig = """
		template <typename ret>
		static char* buildSig() {
			return buildSig(TypeInfo<ret>::sig(), NULL, 0);
		}
"""

buildSig = """
		template <{1}>
		static char* buildSig() {0}
			const char* args[] = {0}{2}
			{3};
			return buildSig(TypeInfo<ret>::sig(), args);
		{3}
"""

sig_suffix = """
	};
"""
class InvokeMethod:
    def __init__(self, getter, isStatic):
        self.getter = getter
        self._isStatic = isStatic
    def call(self, dst, args):
        return "TypeInfo<ret>::%s(env)(env, %s, base_t::m_method%s);" % (self.getter, dst, args)
    def isStatic(self): return self._isStatic
    def isCtor(self): return False

class InvokeConstructor:
    def call(self, dst, args):
        return "env->NewObject(%s, base_t::m_method%s);" % (dst, args)
    def isStatic(self): return False
    def isCtor(self): return True

def _spin_list(tmplt, count):
    out = []
    for i in range(count):
        ndx = i + 1
        out.append(tmplt.format(ndx))
    return out
    
def _spin(tmplt, count):
    return ", ".join(_spin_list(tmplt, count))

class GeneratorBase:
    def store(self, fileName):
    	print "../includes/jini/"+fileName
        f = open("../includes/jini/"+fileName, "w")
        self.internal_store(f, fileName, g_counts)
        f.close()

    def internal_store(self, out, fileName, count):
        guard = fileName.upper().replace(".", "_").replace("/", "_")

        out.write(prefix.format(fileName, guard, "{"))

        self.store_contents(out, count)

        out.write(suffix.format(guard, "}"))
        pass
    
    def store_contents(self, out, count):
        pass

class Generator(GeneratorBase):
    def __init__(self, klass, invoker):
        self.klass = klass
        self.invoker = invoker
    
    def store_contents(self, out, count):
        out.write("\t")
        out.write(self._template(count, "typename T{0} = NullT", True))
        out.write(" class %s;\n\n" % self.klass)
        
        for i in range(count+1):
            self.internal_store_concretization(out, i)

    def internal_store_concretization(self, out, count):
        template_line = self._template(count)

        if self.invoker.isCtor():
            arg = ""
            outtype = "jobject"
            call_arg = "jclass clazz"
            forward_dst = "clazz"
            called_dst = "clazz"
            name_call = "\"<init>\""
            types = []
            types2 = ["void"]
        else:
            arg = "const char* name"
            outtype = "ret"
            call_arg = "jclass clazz, jobject thiz"
            forward_dst = "thiz"
            called_dst = "clazz, thiz"
            name_call = "name"
            types = ["ret"]
            types2 = ["ret"]

        if self.invoker.isStatic():
            static = ", true"
            call_arg = "jclass clazz"
            forward_dst = "clazz"
            called_dst = "clazz"
        else:
            static = ""

        t = _spin_list("T{0}", count)
        types = ", ".join(types + t)
        types2 = ", ".join(types2 + t)

        call_args = [call_arg] + _spin_list("T{0} arg{0}", count)

        spin = _spin("JNIconv(arg{0})", count)
        if count > 0: spin = ", " + spin

        arg_spin = _spin_list("arg{0}", count)
        called_args = [called_dst] + arg_spin
        forward_args = [forward_dst] + arg_spin

        out.write(class_prefix.format("{", self.klass, template_line, types, arg, name_call, static, types2, "}"))
        out.write(class_suffix.format("{",
                                      outtype,
                                      ", ".join(call_args),
                                      self.invoker.call(forward_dst, spin),
                                      ", ".join(forward_args),
                                      ", ".join(called_args),
                                      "}"))

    def _template(self, count, tmplt = "typename T{0}", onemore = False):
        out = "template <"
        if not self.invoker.isCtor():
            out += "typename ret"
            if count > 0: out += ", "
        out += _spin(tmplt, count)
        if onemore: out += ", typename OneMore = NullT"
        return out + ">"

class SigGenerator(GeneratorBase):
    def store_contents(self, out, count):
        out.write(sig_prefix)
        for size in range(g_counts + 1):
            if size == 0: out.write(null_buildSig)
            else:
                types = ["typename ret"] + _spin_list("typename T{0}", size)
                spin = _spin_list("\n                TypeInfo<T{0}>::sig()", size)
                out.write(buildSig.format("{", ", ".join(types), ",".join(spin), "}"))
        out.write(sig_suffix)

def main():
    Generator("Method", InvokeMethod("get_function", False)).store("methods.hpp")
    Generator("StaticMethod", InvokeMethod("get_static_function", True)).store("static_methods.hpp")
    Generator("Constructor", InvokeConstructor()).store("constructors.hpp")
    SigGenerator().store("signatures.hpp")
main()
